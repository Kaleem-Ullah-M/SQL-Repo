/* THIS SQL FILE CONTAINS ADVANCED QUERIES USED TO RETRIVE VITAL INFORMATION FROM MUSIC DATABASE.
LINE 86 ,95 CHECK AGAIN



*/

CREATE DATABASE iMedia;
USE iMedia;


CREATE TABLE ARTIST(
		ARTIST_ID INT PRIMARY KEY,
        ARTIST_NAME VARCHAR(20) NOT NULL,
        ARTIST_DOB DATE,
        GENRE_ID INTEGER,
        FOREIGN KEY (GENRE_ID) REFERENCES GENRE(GENRE_ID));


CREATE TABLE ALBUM(
		ALBUM_ID INT PRIMARY KEY,
        ALBUM_TITLE VARCHAR(20) NOT NULL,
        ALBUM_RELEASE_DATE DATE,
        ARTIST_ID INT,
		FOREIGN KEY (ARTIST_ID) REFERENCES ARTIST (ARTIST_ID));

CREATE TABLE TRACK(
		TRACK_ID INT PRIMARY KEY,
        TRACK_TITLE VARCHAR(20) NOT NULL,
        TRACK_DURATION INT CHECK (TRACK_DURATION > 0),
        ALBUM_ID INT,
        FOREIGN KEY (ALBUM_ID) REFERENCES ALBUM(ALBUM_ID));
        
	
CREATE TABLE GENRE(
		GENRE_ID INT PRIMARY KEY,
        GENRE_NAME TEXT);


CREATE INDEX IDX_ARTIST_NAME ON ARTIST(ARTIST_NAME);
CREATE INDEX IDX_ALBUM_TITLE ON ALBUM(ALBUM_TITLE);
CREATE INDEX IDX_TRACK_TITLE ON TRACK(TRACK_TITLE);
CREATE INDEX IDX_GENRE_TITLE ON GENRE(GENRE_NAME(50));


SHOW INDEX FROM TRACK;

/* ETL = EXTRACT TRANSFORM AND LOAD DATA --
ETL Process: ETL stands for Extract, Transform, and Load. It's a critical process in data warehousing and business intelligence,
used to collect data from various sources, convert it into a suitable format, and load it into a target database.
Importance of ETL: ETL is essential for data integration, cleaning, transformation, and loading,
ensuring data quality and consistency. 

*/
-- EXTRACTION:  for Extraction used the Table Data Import Wizard.


-- TRANSFORM: here we make sure that the tables follow integritu rules.alter

-- 1: CHANGING COLUMN NAME: 
ALTER TABLE ALBUMS_RAW
CHANGE COLUMN `Ã¯Â»Â¿ALBUM_ID` ALBUM_ID INT;

ALTER TABLE ARTISTS_RAW
CHANGE COLUMN `Ã¯Â»Â¿ARTIST_ID` ARTIST_ID INT;

ALTER TABLE TRACKS_RAW
CHANGE COLUMN `Ã¯Â»Â¿TRACK_ID` TRACK_ID INT;

-- 2: CHECKING REFERENTIAL INTEGRITY
SET SQL_SAFE_UPDATES = 0; -- TO TURN OFF SAFE MODE

DELETE FROM ALBUMS_RAW WHERE ARTIST_ID NOT IN (SELECT ARTIST_ID FROM ARTISTS_RAW);
DELETE FROM ARTISTS_RAW WHERE GENRE_ID NOT IN (SELECT GENRE_ID FROM GENRES_RAW);
DELETE FROM TRACKS_RAW WHERE ALBUM_ID NOT IN (SELECT ALBUM_ID FROM ALBUMS_RAW);

SET SQL_SAFE_UPDATES = 1;

-- ARTISTS_RAW TABLE: 1: REMOVE NULLS AND BLANKS FROM NAME ATRIST_NAME, REMOVE DUPLICATE VALUES , REMOVE WHITE SPACES, REFRENTIAL INTEGRITY.
SELECT * FROM ARTISTS_RAW;
DELETE FROM ARTISTS_RAW WHERE ARTIST_NAME IS NULL OR ARTIST_NAME = '';
UPDATE ARTISTS_RAW SET ARTIST_NAME = TRIM(ARTIST_NAME);
DELETE FROM ARTISTS_RAW WHERE ARTIST_NAME NOT IN (SELECT ARTIST_ID FROM ARTISTS_RAW GROUP BY ARTIST_ID);

DELETE FROM ARTISTS_RAW
WHERE ARTIST_ID NOT IN (
    SELECT * FROM (
        SELECT MIN(ARTIST_ID)
        FROM ARTISTS_RAW
        GROUP BY ARTIST_NAME
    ) AS temp
); -- REMOVES DUPLICATES

-- ALBUMS_RAW TABLE: REMOVES NULL OR BLANKS IN ALBUM_TITLE, TRIMS ALBUM_TITLE , REMOVES DUPLICATE AND CHECKS REFERENTIAL INTEGRITY.

DELETE FROM ALBUMS_RAW WHERE ALBUM_TITLE IS NULL OR ALBUM_TITLE = '';
UPDATE ALBUMS_RAW SET ALBUM_TITLE = TRIM(ALBUM_TITLE);
DELETE FROM ALBUMS_RAW
WHERE ALBUM_ID NOT IN (
    SELECT * FROM (
        SELECT MIN(ALBUM_ID)
        FROM ALBUMS_RAW
        GROUP BY ALBUM_TITLE
    ) AS temp
); -- CHECKS DUPLICATES

-- TRACKS_RAW: REMOVES NULL OR BLANKS IN ALBUM_TITLE, TRIMS ALBUM_TITLE , REMOVES DUPLICATE AND CHECKS REFERENTIAL INTEGRITY

DELETE FROM TRACKS_RAW WHERE TRACK_TITLE IS NULL OR TRACK_TITLE = ''; 
DELETE FROM TRACKS_RAW WHERE TRACK_DURATION <= 0; -- REMOVES DURATION EQUAL TO 0 OR LESS.
UPDATE TRACKS_RAW SET TRACK_TITLE = TRACK_TITLE * 60 ; -- CONVERTS THE MINUTES INTO SECONDS.
UPDATE TRACKS_RAW SET TRACK_TITLE = TRIM(TRACK_TITLE); -- TRIMS THE WHITE SPACES.
DELETE FROM TRACKS_RAW
WHERE TRACK_ID NOT IN (
    SELECT * FROM (
        SELECT MIN(_ID)
        FROM TRACKSS_RAW
        GROUP BY TRACKS_TITLE
    ) AS temp
); -- CHECKS DUPLICATES

-- GENRES_RAW: 
 
DELETE FROM GENRES_RAW WHERE GENRE_NAME IS NULL OR GENRE_NAME = '';


-- LOAD: LOADING THE CLEANED DATA INTO THE TABLES FROM THE CLEANED TABLES.

SET FOREIGN_KEY_CHECKS = OFF;

INSERT INTO GENRE (GENRE_ID, GENRE_NAME)
SELECT GENRE_ID ,GENRE_NAME FROM GENRES_RAW;

INSERT INTO ARTIST (ARTIST_ID, ARTIST_NAME, ARTIST_DOB, GENRE_ID)
SELECT ARTIST_ID, ARTIST_NAME, STR_TO_DATE(NULLIF(ARTIST_DOB, ''), '%c/%e/%Y'), GENRE_ID FROM ARTISTS_RAW;

INSERT INTO ALBUM (ALBUM_ID, ALBUM_TITLE, ALBUM_RELEASE_DATE, ARTIST_ID)
SELECT ALBUM_ID, ALBUM_TITLE, STR_TO_DATE(NULLIF(ALBUM_RELEASE_DATE,''), '%c/%e/%Y'), ARTIST_ID FROM ALBUMS_RAW;

INSERT INTO TRACK (TRACK_ID, TRACK_TITLE, TRACK_DURATION, ALBUM_ID)
SELECT TRACK_ID, TRACK_TITLE, TRACK_DURATION, ALBUM_ID FROM TRACKS_RAW;


SET FOREIGN_KEY_CHECKS = ON;

-- DROP THE RAW TABLES;
DROP TABLE ALBUMS_RAW;
DROP TABLE GENRES_RAW;
DROP TABLE TRACKS_RAW;
DROP TABLE ARTISTS_RAW;


/* DATA VALIDATION: ENSURE DATA INTEGRITY BEFORE QUERYING.
EG: 1: VALIDATING THE DATES. 	2: CHECKING REFERENTIAL INTEGRITY.

*/
SET SQL_SAFE_UPDATES = 0; -- DISABLE SAGE UPDATE MODE
SET SQL_SAFE_UPDATES = 1;

-- VALIDATING THE DATES(ENSURE NO NULLS IN DATE AND NO DATES BIGGER THAN CURRENT DATE)

-- ALBUMS TABLE;
SELECT * FROM ALBUM WHERE ALBUM_RELEASE_DATE > NOW();  -- (CHECKED NO ROWS ABOVE CURRENT DATE)
SELECT * FROM ALBUM WHERE ALBUM_RELEASE_DATE IS NULL; -- RETURN ROWS 
UPDATE ALBUM SET  ALBUM_RELEASE_DATE ='9999-01-01' WHERE ALBUM_RELEASE_DATE IS NULL; -- REPLACED NULLS WITH SPECIFIED DATE.
SELECT * FROM ALBUM WHERE ARTIST_ID NOT IN (SELECT ARTIST_ID FROM ARTIST); -- CHECKING REFERENTIAL INTEGRITY
DELETE FROM ALBUM WHERE ARTIST_ID NOT IN (SELECT ARTIST_ID FROM ARTIST); -- DELETING ROWS THAT AFFECT REFERENTIAL INTEGRITY.

-- ARTIST TABLE: 
SELECT * FROM ARTIST WHERE ARTIST_DOB > NOW();
SELECT * FROM ARTIST WHERE ARTIST_DOB IS NULL; 
UPDATE ARTIST SET ARTIST_DOB = '9999-12-31' WHERE ARTIST_DOB IS NULL; -- REPLACED NULL WITH SPECIFIED DATE.
SELECT * FROM ARTIST WHERE GENRE_ID NOT IN (SELECT GENRE_ID FROM GENRE); -- CHECKED REFERENTIAL INTEGRITY.



-- QUERIES: 
-- Q1: SELECT ARTISTS WITH GENRE_ID 2 (POP).
SELECT * FROM ARTIST WHERE GENRE_ID = 2;

-- Q2: COUNTING THE ROWS BY ARTIST_NAME.
SELECT COUNT(ARTIST_NAME) FROM ARTIST;

-- Q3: GROUPING ARTIST TABLE BY GENRE_ID.
SELECT GENRE_ID ,COUNT(ARTIST_ID) FROM ARTIST GROUP BY GENRE_ID;

-- Q4: GROUP DATA BY GENRE_ID AND SELECT THOSE GENRE THAT HAVE COUNT OF MORE THAN 5.
SELECT ARTIST.GENRE_ID, GENRE_NAME , COUNT(ARTIST_ID) FROM GENRE 
JOIN ARTIST ON GENRE.GENRE_ID = ARTIST.GENRE_ID GROUP BY GENRE_ID  HAVING COUNT(ARTIST_ID) > 5;

-- Q5: FIND TOP ARTIST BY NUMBER OF ALBUMS;
SELECT ARTIST.ARTIST_ID ,ARTIST_NAME,COUNT(ALBUM_ID) FROM ALBUM 
JOIN ARTIST ON ARTIST.ARTIST_ID = ALBUM.ARTIST_ID GROUP BY ARTIST_NAME ,ARTIST.ARTIST_ID ;

-- Q6: IDENTIFY POPULAR GENRE AMONG ARTISTS.
SELECT  ARTIST.GENRE_ID, GENRE_NAME ,COUNT(ARTIST.GENRE_ID) FROM ARTIST JOIN GENRE ON ARTIST.GENRE_ID = GENRE.GENRE_ID 
GROUP BY ARTIST.GENRE_ID, GENRE_NAME ORDER BY COUNT(ARTIST.GENRE_ID) DESC LIMIT 1;


-- Q7: ISERT A ROW INTO ARTIST WITH NAME THE WEEKND, DOB AS FEB-16-1990 UNDER POP.
INSERT INTO ARTIST(ARTIST_ID, ARTIST_NAME, ARTIST_DOB, GENRE_ID) VALUES(101,"THE WEEKND", '1990-02-16',2);

-- Q8; ADD THE PREFIX CLASSIC TO ALL TRACK_TITLE WHICH ARE OLDER THAN 2010.
UPDATE 

/*
How would you update all albums released before 2010 to have the title prefixed with "Classic - "?

âš™ï¸ Section 2: Retrieval & Filtering

Write a query to list all tracks longer than 240 seconds.

Retrieve all album titles released by â€œAdele.â€

Find all artists who donâ€™t have any albums yet.

Display all genres that have no artists linked to them.

Write a query to find the artist with the most albums.

ðŸ“Š Section 3: Aggregation & GROUP BY

Display each artistâ€™s name along with the total number of albums theyâ€™ve released.

Find the average track duration for each album.

Show artists who have more than 3 albums.

Write a query to find the total number of tracks in each genre.

What is the difference between WHERE and HAVING in an aggregate query?

ðŸ§  Section 4: JOINs & Relationships

Write a query to show each trackâ€™s title, its album title, and the artistâ€™s name.

Display all albums along with their genre names (via the artistâ€™s genre link).

Find all tracks that belong to albums released after 2020.

Write a query to list each artist and the total duration of all their tracks combined.

Explain the difference between INNER JOIN, LEFT JOIN, and RIGHT JOIN â€” and give examples based on your database.

âš¡ Section 5: Constraints & Indexes

Why did you add the CHECK (TRACK_DURATION > 0) constraint?

What happens if you try to delete a GENRE that is referenced by an artist?

How could you modify the foreign key so that when a genre is deleted, the artistâ€™s genre becomes NULL instead of throwing an error?

Whatâ€™s the benefit of adding indexes on columns like ARTIST_NAME and ALBUM_TITLE?

What does this index do:

CREATE INDEX IDX_GENRE_TITLE ON GENRE(GENRE_NAME(50));


Why did you specify (50)?

ðŸš€ Section 6: Optimization & Administration

How would you detect duplicate artist names in your database?

If queries joining ARTIST and ALBUM become slow, what steps could you take to optimize performance?

What is a composite index, and where might it be useful in this schema?

How would you back up the iMedia database and restore it on another server?

If the database grows very large, what techniques would you use to improve read performance without changing the schema?
*/